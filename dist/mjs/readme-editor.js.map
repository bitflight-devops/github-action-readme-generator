{"version":3,"file":"readme-editor.js","sourceRoot":"","sources":["../../src/readme-editor.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,KAAK,EAAE,MAAM,SAAS,CAAC;AAC9B,OAAO,EAAE,GAAG,EAAE,MAAM,SAAS,CAAC;AAE9B,OAAO,OAAO,MAAM,oBAAoB,CAAC;AACzC,OAAO,EAAE,cAAc,EAAE,MAAM,eAAe,CAAC;AAE/C;;GAEG;AACH,MAAM,CAAC,MAAM,gBAAgB,GAAG,mBAAmB,CAAC;AAEpD;;GAEG;AACH,MAAM,CAAC,MAAM,cAAc,GAAG,iBAAiB,CAAC;AAEhD,MAAM,CAAC,OAAO,OAAO,YAAY;IACd,QAAQ,CAAS;IAE1B,WAAW,CAAS;IAE5B;;;OAGG;IACH,YAAY,QAAgB;QAC1B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC,YAAY,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;IACvD,CAAC;IAED;;;;OAIG;IACH,eAAe,CAAC,KAAa;QAC3B,MAAM,UAAU,GAAG,gBAAgB,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QACzD,MAAM,SAAS,GAAG,cAAc,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QACtD,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;QACzF,MAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QACtD,OAAO,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;IACjC,CAAC;IAED;;;;;OAKG;IACH,aAAa,CAAC,IAAY,EAAE,eAAkC,EAAE,WAAW,GAAG,IAAI;QAChF,MAAM,GAAG,GAAG,IAAI,OAAO,CAAC,IAAI,CAAC,CAAC;QAC9B,MAAM,OAAO,GAAG,CACd,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,eAAe,IAAI,EAAE,CACnF,CAAC,IAAI,EAAE,CAAC;QACT,GAAG,CAAC,IAAI,CAAC,mBAAmB,IAAI,aAAa,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;QAE9D,MAAM,CAAC,UAAU,EAAE,SAAS,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QAC3D,IAAI,UAAU,KAAK,CAAC,CAAC,IAAI,SAAS,KAAK,CAAC,CAAC,EAAE;YACzC,MAAM,aAAa,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;YAC5D,MAAM,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;YAEvD,IAAI,CAAC,WAAW,GAAG,WAAW;gBAC5B,CAAC,CAAC,GAAG,aAAa,OAAO,OAAO,KAAK,YAAY,EAAE;gBACnD,CAAC,CAAC,GAAG,aAAa,GAAG,OAAO,GAAG,YAAY,EAAE,CAAC;SACjD;aAAM,IAAI,SAAS,GAAG,UAAU,IAAI,IAAI,KAAK,UAAU,EAAE;YACxD,MAAM,IAAI,KAAK,CAAC,4BAA4B,IAAI,gCAAgC,CAAC,CAAC;SACnF;IACH,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,UAAU;QACd,MAAM,OAAO,GAAG,MAAM,cAAc,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACvD,OAAO,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;IAC1D,CAAC;CACF","sourcesContent":["/**\n * This TypeScript code imports the necessary modules and defines a class named `ReadmeEditor`.\n * The class represents an editor for modifying a README file.\n * It has methods to update specific sections within the file and dump the modified content back to the file.\n */\n\nimport * as fs from 'node:fs';\nimport { EOL } from 'node:os';\n\nimport LogTask from './logtask/index.js';\nimport { formatMarkdown } from './prettier.js';\n\n/**\n * The format for the start token of a section.\n */\nexport const startTokenFormat = '<!-- start %s -->';\n\n/**\n * The format for the end token of a section.\n */\nexport const endTokenFormat = '<!-- end %s -->';\n\nexport default class ReadmeEditor {\n  private readonly filePath: string;\n\n  private fileContent: string;\n\n  /**\n   * Creates a new instance of `ReadmeEditor`.\n   * @param {string} filePath - The path to the README file.\n   */\n  constructor(filePath: string) {\n    this.filePath = filePath;\n    this.fileContent = fs.readFileSync(filePath, 'utf8');\n  }\n\n  /**\n   * Gets the indexes of the start and end tokens for a given section.\n   * @param {string} token - The section token.\n   * @returns {number[]} - The indexes of the start and end tokens.\n   */\n  getTokenIndexes(token: string): number[] {\n    const startToken = startTokenFormat.replace('%s', token);\n    const stopToken = endTokenFormat.replace('%s', token);\n    const startIndex = Math.max(0, this.fileContent.indexOf(startToken) + startToken.length);\n    const stopIndex = this.fileContent.indexOf(stopToken);\n    return [startIndex, stopIndex];\n  }\n\n  /**\n   * Updates a specific section in the README file with the provided content.\n   * @param {string} name - The name of the section.\n   * @param {string | string[]} providedContent - The content to update the section with.\n   * @param {boolean} addNewlines - Whether to add newlines before and after the content.\n   */\n  updateSection(name: string, providedContent: string | string[], addNewlines = true): void {\n    const log = new LogTask(name);\n    const content = (\n      Array.isArray(providedContent) ? providedContent.join(EOL) : providedContent ?? ''\n    ).trim();\n    log.info(`Looking for the ${name} token in ${this.filePath}`);\n\n    const [startIndex, stopIndex] = this.getTokenIndexes(name);\n    if (startIndex !== -1 && stopIndex !== -1) {\n      const beforeContent = this.fileContent.slice(0, startIndex);\n      const afterContent = this.fileContent.slice(stopIndex);\n\n      this.fileContent = addNewlines\n        ? `${beforeContent}\\n\\n${content}\\n${afterContent}`\n        : `${beforeContent}${content}${afterContent}`;\n    } else if (stopIndex < startIndex && name !== 'branding') {\n      throw new Error(`Start token for section '${name}' must appear before end token`);\n    }\n  }\n\n  /**\n   * Dumps the modified content back to the README file.\n   * @returns {Promise<void>}\n   */\n  async dumpToFile(): Promise<void> {\n    const content = await formatMarkdown(this.fileContent);\n    return fs.writeFileSync(this.filePath, content, 'utf8');\n  }\n}\n"]}