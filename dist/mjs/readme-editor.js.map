{"version":3,"file":"readme-editor.js","sourceRoot":"","sources":["../../src/readme-editor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * This TypeScript code imports the necessary modules and defines a class named `ReadmeEditor`.\n * The class represents an editor for modifying a README file.\n * It has methods to update specific sections within the file and dump the modified content back to the file.\n */\n\nimport * as fs from 'node:fs';\nimport { EOL } from 'node:os';\n\nimport LogTask from './logtask/index.js';\nimport { formatMarkdown } from './prettier.js';\n\n/**\n * The format for the start token of a section.\n */\nexport const startTokenFormat = '<!-- start %s -->';\n\n/**\n * The format for the end token of a section.\n */\nexport const endTokenFormat = '<!-- end %s -->';\n\nexport default class ReadmeEditor {\n  private log = new LogTask('ReadmeEditor');\n\n  /**\n   * The path to the README file.\n   */\n  private readonly filePath: string;\n\n  private fileContent: string;\n\n  /**\n   * Creates a new instance of `ReadmeEditor`.\n   * @param {string} filePath - The path to the README file.\n   */\n  constructor(filePath: string) {\n    this.filePath = filePath;\n    try {\n      fs.accessSync(filePath);\n      this.fileContent = fs.readFileSync(filePath, 'utf8');\n    } catch (error) {\n      this.log.fail(`Readme at '${filePath}' does not exist.`);\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the indexes of the start and end tokens for a given section.\n   * @param {string} token - The section token.\n   * @returns {number[]} - The indexes of the start and end tokens.\n   */\n  getTokenIndexes(token: string, logTask?: LogTask): number[] {\n    const log = logTask ?? new LogTask('getTokenIndexes');\n    const startToken = startTokenFormat.replace('%s', token);\n    const stopToken = endTokenFormat.replace('%s', token);\n    const startIndex = Math.max(0, this.fileContent.indexOf(startToken) + startToken.length);\n    const stopIndex = this.fileContent.indexOf(stopToken);\n\n    if (startIndex === -1 && stopIndex === -1) {\n      log.debug(`No start or end token found for section '${token}'. Skipping`);\n      return [];\n    }\n\n    if (stopIndex === -1) {\n      throw new Error(`End token for section '${token}' not found.`);\n    }\n\n    if (startIndex === -1) {\n      throw new Error(`Start token for section '${token}' not found.`);\n    }\n\n    if (stopIndex < startIndex && token !== 'branding') {\n      throw new Error(`Start token for section '${token}' must appear before end token`);\n    }\n\n    return [startIndex, stopIndex];\n  }\n\n  /**\n   * Updates a specific section in the README file with the provided content.\n   * @param {string} name - The name of the section.\n   * @param {string | string[]} providedContent - The content to update the section with.\n   * @param {boolean} addNewlines - Whether to add newlines before and after the content.\n   */\n  updateSection(name: string, providedContent: string | string[], addNewlines = true): void {\n    const log = new LogTask(name);\n    const content = (\n      Array.isArray(providedContent) ? providedContent.join(EOL) : providedContent ?? ''\n    ).trim();\n    log.info(`Looking for the ${name} token in ${this.filePath}`);\n\n    const [startIndex, stopIndex] = this.getTokenIndexes(name, log);\n    if (startIndex && stopIndex) {\n      const beforeContent = this.fileContent.slice(0, startIndex);\n      const afterContent = this.fileContent.slice(stopIndex);\n\n      this.fileContent = addNewlines\n        ? `${beforeContent}\\n\\n${content}\\n${afterContent}`\n        : `${beforeContent}${content}${afterContent}`;\n    }\n  }\n\n  /**\n   * Dumps the modified content back to the README file.\n   * @returns {Promise<void>}\n   */\n  async dumpToFile(): Promise<void> {\n    const content = await formatMarkdown(this.fileContent);\n    return fs.promises.writeFile(this.filePath, content, 'utf8');\n  }\n}\n"]}