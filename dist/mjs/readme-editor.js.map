{"version":3,"file":"readme-editor.js","sourceRoot":"","sources":["../../src/readme-editor.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,MAAM,SAAS,CAAC;AAC9B,OAAO,EAAE,GAAG,EAAE,MAAM,SAAS,CAAC;AAE9B,OAAO,OAAO,MAAM,oBAAoB,CAAC;AACzC,OAAO,EAAE,cAAc,EAAE,MAAM,eAAe,CAAC;AAE/C,MAAM,CAAC,MAAM,gBAAgB,GAAG,mBAAmB,CAAC;AACpD,MAAM,CAAC,MAAM,cAAc,GAAG,iBAAiB,CAAC;AAEhD,MAAM,CAAC,OAAO,OAAO,YAAY;IACd,QAAQ,CAAS;IAE1B,WAAW,CAAS;IAE5B,YAAY,QAAgB;QAC1B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC,YAAY,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;IACvD,CAAC;IAED,aAAa,CAAC,IAAY,EAAE,eAAkC;QAC5D,MAAM,GAAG,GAAG,IAAI,OAAO,CAAC,IAAI,CAAC,CAAC;QAC9B,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC;QAC7F,GAAG,CAAC,IAAI,CAAC,mBAAmB,IAAI,aAAa,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;QAC9D,MAAM,UAAU,GAAG,gBAAgB,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACxD,MAAM,SAAS,GAAG,cAAc,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAErD,MAAM,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;QACxD,MAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QAEtD,IAAI,UAAU,KAAK,CAAC,CAAC,IAAI,SAAS,KAAK,CAAC,CAAC,EAAE;YACzC,MAAM,aAAa,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;YAC7F,MAAM,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;YAEvD,IAAI,CAAC,WAAW,GAAG,GAAG,aAAa,KAAK,OAAO,KAAK,YAAY,EAAE,CAAC;SACpE;aAAM,IAAI,SAAS,GAAG,UAAU,EAAE;YACjC,MAAM,IAAI,KAAK,CAAC,4BAA4B,IAAI,+BAA+B,CAAC,CAAC;SAClF;IACH,CAAC;IAED,KAAK,CAAC,UAAU;QACd,MAAM,OAAO,GAAG,MAAM,cAAc,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACvD,OAAO,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;IAC1D,CAAC;CACF","sourcesContent":["import * as fs from 'node:fs';\nimport { EOL } from 'node:os';\n\nimport LogTask from './logtask/index.js';\nimport { formatMarkdown } from './prettier.js';\n\nexport const startTokenFormat = '<!-- start %s -->';\nexport const endTokenFormat = '<!-- end %s -->';\n\nexport default class ReadmeEditor {\n  private readonly filePath: string;\n\n  private fileContent: string;\n\n  constructor(filePath: string) {\n    this.filePath = filePath;\n    this.fileContent = fs.readFileSync(filePath, 'utf8');\n  }\n\n  updateSection(name: string, providedContent: string | string[]): void {\n    const log = new LogTask(name);\n    const content = Array.isArray(providedContent) ? providedContent.join(EOL) : providedContent;\n    log.info(`Looking for the ${name} token in ${this.filePath}`);\n    const startToken = startTokenFormat.replace('%s', name);\n    const stopToken = endTokenFormat.replace('%s', name);\n\n    const startIndex = this.fileContent.indexOf(startToken);\n    const stopIndex = this.fileContent.indexOf(stopToken);\n\n    if (startIndex !== -1 && stopIndex !== -1) {\n      const beforeContent = this.fileContent.slice(0, Math.max(0, startIndex + startToken.length));\n      const afterContent = this.fileContent.slice(stopIndex);\n\n      this.fileContent = `${beforeContent}\\n${content}\\n${afterContent}`;\n    } else if (stopIndex < startIndex) {\n      throw new Error(`Start token for section '${name} must appear before end token`);\n    }\n  }\n\n  async dumpToFile(): Promise<void> {\n    const content = await formatMarkdown(this.fileContent);\n    return fs.writeFileSync(this.filePath, content, 'utf8');\n  }\n}\n"]}